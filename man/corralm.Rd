% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/corralm.R
\name{corralm_matlist}
\alias{corralm_matlist}
\alias{corralm_sce}
\alias{corralm}
\title{Multi-table correspondence analysis (list of matrices)}
\usage{
corralm_matlist(matlist, method = c("irl", "svd")[1], ncomp = 10, ...)

corralm_sce(
  sce,
  splitby,
  method = c("irl", "svd")[1],
  ncomp = 10,
  whichmat = "counts",
  ...
)

corralm(inp, ...)
}
\arguments{
\item{matlist}{(for \code{corralm_matlist}) list of input matrices; input matrices should be counts (raw or log). Matrices should be aligned row-wise by common features (either by sample or by gene)}

\item{method}{character, the algorithm to be used for svd. Default is irl. Currently supports 'irl' for irlba::irlba or 'svd' for stats::svd}

\item{ncomp}{numeric, number of components; Default is 10}

\item{...}{}

\item{sce}{(for \code{corralm_sce}) SingleCellExperiment; containing the data to be integrated. Default is to use the counts, and to include all of the data in the integration. These can be changed by passing additional arguments. See \code{\link{sce2matlist}} function documentation for list of available parameters.}

\item{splitby}{character; name of the attribute from \code{colData} that should be used to separate the SCE}

\item{whichmat}{character; defaults to \code{counts}, can also use \code{logcounts} or \code{normcounts} if stored in the \code{sce} object}

\item{inp}{list of matrices (any type), \code{SingleCellExperiment}, or list of \code{SingleCellExperiment}s. If using \code{SingleCellExperiment}, then include the \code{whichmat} argument to specify which slot to use (defaults to \code{counts}).}
}
\value{
When run on a list of matrices, a list with the correspondence analysis matrix decomposition result, with indices corresponding to the concatenated matrices (in order of the list):
\describe{
    \item{d}{a vector of the diagonal singular values of the input \code{mat}}
    \item{u}{a matrix of with the left singular vectors of \code{mat} in the columns}
    \item{v}{a matrix of with the right singular vectors of \code{mat} in the columns. When cells are in the columns, these are the cell embeddings.}
}

For SingleCellExperiment input, returns the SCE with embeddings in the reducedDim slot 'corralm'

For a list of \code{\link{SingleCellExperiment}}s, returns a list of the SCEs with the embeddings in the respective \code{reducedDim} slot 'corralm'
}
\description{
This multi-table adaptation of correpondence analysis applies the same scaling technique and enables data alignment by finding a set of embeddings for each dataset within shared latent space.
}
\details{
\code{corralm} is a wrapper for \code{\link{corralm_matlist}} and \code{\link{corralm_sce}}, and can be called on any of the acceptable input types (see \code{inp} below).
}
\examples{
listofmats <- list(matrix(sample(seq(0,20,1),1000,replace = TRUE),nrow = 20),matrix(sample(seq(0,20,1),1000,replace = TRUE),nrow = 20))
corralm_matlist(listofmats)
library(DuoClustering2018)
sce <- sce_full_Zhengmix4eq()[1:100,sample(1:3500,100,replace = FALSE)]
# for illustrative purposes only; would not actually use splitby = "phenoid"
# would instead use a batch or platform attribute
result <- corralm_sce(sce, splitby = 'phenoid')

#' # example on how to add UMAP/tsne based on corralm above, with 'scater' package
library(scater)
result <- runUMAP(result, dimred = 'corralm', name = 'corralm_UMAP')
result <- runTSNE(result, dimred = 'corralm', name = 'corralm_TSNE')

listofmats <- list(matrix(sample(seq(0,20,1),1000,replace = TRUE),nrow = 20),matrix(sample(seq(0,20,1),1000,replace = TRUE),nrow = 20))
corralm(listofmats)

library(DuoClustering2018)
sce <- sce_full_Zhengmix4eq()[1:100,sample(1:3500,100,replace = FALSE)]
# for illustrative purposes only; would not actually use splitby = "phenoid"
# would instead use a batch or platform attribute
result <- corralm(sce, splitby = 'phenoid')

}
